# 아키텍처 심화 가이드: SOLID 원칙과 컴포넌트 분리

## 1. 서론: 좋은 설계의 두 가지 관점

좋은 소프트웨어 아키텍처를 구축하기 위해서는 두 가지 관점의 질문에 답할 수 있어야 합니다.

1.  **왜(Why):** 우리는 왜 아키텍처를 개선해야 하는가? (거시적 관점: SOLID 원칙)
2.  **어떻게(How):** 우리는 무엇을 기준으로 코드를 분리해야 하는가? (미시적 관점: 컴포넌트 추출 기준)

이 문서는 `product` 모듈의 리팩토링 방향을 예시로, 이 두 가지 관점이 어떻게 서로를 보완하며 더 나은 설계로 나아가는 길을 제시하는지 설명합니다.

---

## 2. "왜?" - 리팩토링의 목표: 개방/폐쇄 원칙(OCP) 달성

이전 분석에서 현재 아키텍처는 단일 책임(S), 인터페이스 분리(I), 의존성 역전(D) 원칙을 매우 잘 따르고 있음을 확인했습니다. 여기서 아키텍처를 한 단계 더 발전시키기 위한 우리의 목표는 **개방/폐쇄 원칙(Open/Closed Principle, OCP)**을 만족시키는 것입니다.

> **개방/폐쇄 원칙:** 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

즉, **"새로운 기능을 추가할 때 기존 코드를 건드리지 않게 만들자"**는 것이 우리의 목표입니다.

`ProductCreateUseCase`를 예로 들면, "상품 등록 시 슬랙 알림 보내기"라는 기능 추가를 위해 `ProductCreateUseCase` 자체를 수정하는 것은 OCP에 위배됩니다. 이 문제를 해결하는 가장 강력한 패턴이 바로 **이벤트 기반 아키텍처(Event-Driven Architecture)**입니다.

`UseCase`는 오직 핵심 비즈니스 로직(DB 저장)을 처리하고 `ProductCreatedEvent`라는 이벤트만 발행합니다. 그 이후의 부가적인 처리(이미지 처리, 검색엔진 연동, 슬랙 알림 등)는 모두 이 이벤트를 구독하는 별개의 독립적인 리스너들이 담당하게 만드는 것이 OCP를 만족하는 가장 이상적인 구조입니다.

---

## 3. "어떻게?" - 목표 달성을 위한 실천: 컴포넌트 분리 기준

그렇다면 거시적인 목표(OCP 달성)를 위해, 우리는 코드 레벨에서 어떤 실천적인 결정을 내려야 할까요? 바로 이 지점에서 **"언제 private 헬퍼 메서드를 별도의 컴포넌트로 분리해야 하는가?"** 라는 질문이 등장합니다.

아래 기준들은 코드의 **"변경 이유"**에 초점을 맞춰, 컴포넌트 분리가 필요한 시점을 알려주는 구체적인 지표입니다.

1.  **추상화 수준이 다른가?**: `UseCase`는 고수준의 '정책'을, private 메서드는 저수준의 '구현'을 다루는가?
2.  **지식의 영역이 다른가?**: private 메서드가 `UseCase`의 비즈니스 지식과는 다른 외부 시스템(예: S3)에 대한 지식을 필요로 하는가?
3.  **재사용될 가능성이 있는가?**: 이 로직이 다른 곳에서도 필요해질 것 같은가?
4.  **독립적으로 테스트하고 싶은가?**: 로직이 복잡하여 별도로 단위 테스트하고 싶은가?

### "왜"와 "어떻게"의 연결점

`ProductUpdateUseCase`에 S3 이미지 처리 로직이 private 메서드로 존재한다고 가정해 봅시다.

-   이 private 메서드는 **변경 이유**가 다릅니다. (UseCase는 비즈니스 정책 변경 시, S3 로직은 AWS 스펙 변경 시)
-   **지식의 영역**도 다릅니다. (비즈니스 vs S3 SDK)
-   따라서 위 기준에 따라 이 로직은 `ImageManager`라는 별도의 컴포넌트로 **분리(How)**되어야 합니다.

이렇게 컴포넌트를 분리하는 것은 그 자체로 **단일 책임 원칙(S)과 의존성 역전 원칙(D)을 만족**시키는 훌륭한 리팩토링입니다.

이제 한 걸음 더 나아가, `UseCase`와 분리된 `ImageManager` 사이의 관계를 살펴봅시다. `UseCase`가 `ImageManager`를 직접 호출하는 대신, `UseCase`는 오직 **이벤트만 발행**하고, `ImageProcessingListener`가 그 이벤트를 받아 `ImageManager`를 호출하도록 변경합니다.

이러한 변경을 통해 우리는 마침내 **개방/폐쇄 원칙(OCP)을 만족(Why)**하게 됩니다. 이제 `UseCase`는 이미지 처리, 슬랙 알림 등 미래에 추가될 어떤 기능에 대해서도 알 필요가 없으며, 수정될 일도 없습니다. 새로운 기능은 그저 새로운 리스너를 추가하는 것만으로 "확장"될 수 있습니다.

## 4. 결론

| 단계 | 설명 | 만족하는 SOLID 원칙 |
| :--- | :--- | :--- |
| **1단계** | UseCase 내부의 private 메서드로 모든 로직 처리 | (원칙 위반 가능성 높음) |
| **2단계** | **컴포넌트 분리 기준**에 따라 `ImageManager` 추출 | **S(단일 책임), D(의존성 역전)** 충족 |
| **3단계** | UseCase와 Manager 사이를 **이벤트**로 연결 | **O(개방/폐쇄)** 충족 |

결론적으로, **"어떻게 분리할 것인가"**에 대한 미시적인 결정들이 모여 **"왜 개선해야 하는가"**라는 거시적인 아키텍처 목표를 달성합니다. 컴포넌트 분리 기준을 꾸준히 적용하여 코드를 작은 단위로 응집도 높게 유지하는 실천이, 결국에는 유연하고 확장 가능한 아키텍처의 초석이 됩니다.
